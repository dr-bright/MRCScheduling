"""MARS simulation, capable of executing schedules generated by MRCS."""

from dataclasses import dataclass
from email.policy import default
import enum
import json
import math
from pprint import pprint
import time
from typing import Any, Sequence, Tuple
from webbrowser import BackgroundBrowser
import cv2
from matplotlib.pyplot import box
import pygame as pg
import pygame.gfxdraw as pg_gfxdraw

import sys
from weakref import ref, proxy
from math import sin, cos
import numpy as np
import bisect
from tqdm import tqdm

import yaml

from .tau import ContigBlock
from .tau.contig.basics import PID, Sum
from .tau.contig.pygame_teleop import PygameTeleop


FPS = 20

pid_p = 2
pid_i = 0.3
pid_d = 2
pid_clip = 100

loc_color = (40, 200, 0)
home_color = (200, 160, 0)
robot_colors = [(50, 10, 0), (200, 0, 0), (200, 100, 0),
                (200, 200, 0), (40, 200, 0), (0, 0, 200),
                (0, 100, 200), (60, 60, 60), (100, 100, 0)]


def load_schedule(schedule):
    if isinstance(schedule, str):
        if schedule.lower().endswith('.yaml'):
            with open(schedule, 'rb') as f:
                schedule = yaml.safe_load(f)
        else:
            with open(schedule, 'rt', encoding='utf-8') as f:
                schedule = json.load(f)
    # now we infer a bunch of things about the schedule
    # TODO: make a separate module for schedule representation
    # because utils.Scheduler uses the same algorithm in .fetch_state
    num_robots = int(schedule.get('robots', 0))
    t = float(schedule.get('near_threshold', 1.0))
    schedule['near_threshold'] = t
    if num_robots == 0:
        for task in schedule['tasks']:
            if np.iterable(task['dur']):
                num_robots = len(task['dur'])
                break
        if num_robots == 0:
            raise ValueError('Task description is malformed:'
                            ' cant infer num_robots')
    schedule['robots'] = num_robots
    if 'homes' not in schedule:
        homes = schedule['homes'] = []
        for i in range(schedule['robots']):
            homes.append([i, 0])
    return schedule


def blit_center(screen: pg.Surface, sprite: pg.Surface, pos):
    sprite_size = np.array(sprite.get_rect()[2:])
    pos = pos - sprite_size // 2
    screen.blit(sprite, pos.astype(int).tolist())


def anticolor(color):
    return (255 - np.array(color)).tolist()


def surf_to_cv(surf: pg.Surface):
    shape = (*surf.get_size()[::-1], 4)
    image = np.frombuffer(pg.image.tobytes(surf, 'BGRA'), np.uint8).reshape(shape)
    return image[:, :, :3]


class Robot(ContigBlock):  # inherit to get access to .dt()
    charge = 400.0
    magnetic_coeff = 800.0
    mass = 1.0
    static_friction = 0.2
    dynamic_friction = 0.5
    force_cap = 500
    color = (60, 60, 60)
    radius = 30

    target: tuple[int, int] | None
    group: 'list[Robot]'

    def __init__(self, pos, group, pid, label=None, font=None):
        self.target = None
        self.pid = pid
        self.pos = np.array(pos, float)
        self.vel = np.array([0,0], float)
        self.acc = np.array([0,0], float)
        self.applied_force = np.array([0,0], float)
        self.group = group
        self.label = label
        self.last_potential_force = None
        if font is None:
            font = pg.font.SysFont('Comic Sans MS', 16)
        self.font = font
    
    def render(self, canvas):
        pg_gfxdraw.filled_circle(canvas,
                                 round(self.pos[0]), round(self.pos[1]),
                                 self.radius, self.color)
        if self.label is not None:
            lbl = self.font.render(self.label, False,
                                   anticolor(self.color))
            blit_center(canvas, lbl, self.pos)
    
    def physics(self, t):
        # use potential to avoid other charges
        # use pid to follow the target
        # pid controls robot acceleration vector
        # max accel is clipped
        # there is friction
        dt = self.dt(t)
        potential_force = np.array([0, 0], float)
        for other in self.group:
            if other is self:
                continue
            dir = np.subtract(self.pos, other.pos, dtype=float)
            distance_squared = sum(dir * dir)
            dir /= np.linalg.norm(dir)
            mag = self.charge * other.charge / distance_squared
            potential_force += dir * mag
        if self.last_potential_force is not None and dt >= 0.0001:
            df = (potential_force - self.last_potential_force) / dt
            self.last_potential_force = potential_force
            electric_dir = potential_force / np.linalg.norm(potential_force)
            magnetic_dir = np.array([*reversed(electric_dir)])
            magnetic_dir[0] *= -1
            magnetic_mag = self.magnetic_coeff * dt
            magnetic_force = magnetic_dir * magnetic_mag
            # print(magnetic_force)
            if not np.isnan(magnetic_force).any():
                potential_force += magnetic_force
        else:
            self.last_potential_force = potential_force
        applied_force = potential_force + self.applied_force
        # static friction is opposite to applied force
        # static friction is equal or less then applied force
        # static friction is no more than a certain limit
        applied_force_mag = np.linalg.norm(applied_force)
        static_friction_dir =  - applied_force / applied_force_mag  # type: ignore
        static_friction_mag = min(self.static_friction, applied_force_mag)
        static_friction = static_friction_dir * static_friction_mag
        if np.isnan(static_friction).any():
            static_friction = np.zeros(2)
        # dynamic friction is proportional to the velocity
        dynamic_friction = - self.dynamic_friction * self.vel
        total_force  = applied_force + static_friction + dynamic_friction
        total_mag = np.linalg.norm(total_force)
        if total_mag > self.force_cap:
            total_force = total_force / total_mag * self.force_cap
        self.pos += (self.vel * dt).round(3)
        self.vel += (self.acc * dt).round(3)
        self.acc = (total_force / self.mass).round(3)
    
    def control(self, t):
        diff = np.zeros(2)
        if self.target is not None:
            diff[:] = np.subtract(self.target, self.pos)
        self.applied_force[:] = self.pid(diff, t)


# TODO: this is a bad approach, refactor this
@dataclass
class Target:  # encapsulate some rendering logic here
    start: float | None
    end: float | None
    label: Any | None
    robot: Robot
    font: pg.font.Font | None = None
    radius: int = 20

    def clear(self):
        self.start = None
        self.stop = None
        self.label = None
        return self
    
    def set(self, task: None | Tuple[float, float, Any, Tuple[int, int]]):
        """
        
        task: [start, end, task_id, pos]"""
        if task is None:
            return self.clear()
        self.start, self.end, self.label, self.pos = task
        self.robot.target = self.pos
        return self

    def render(self, screen: pg.Surface, t: float | None = None):
        if self.robot.target is None:
            return
        r = self.radius
        x, y = self.robot.target
        
        if (self.start is not None and self.end is not None
                and t is not None and t >= self.start
                and t <= self.end):
            pg_gfxdraw.filled_circle(screen, x, y, r, self.robot.color)
            progress = (t - self.start) / (self.end - self.start)
            pg.draw.arc(screen, anticolor(self.robot.color),
                        (x-r, y-r, 2*r, 2*r),
                        np.pi / 2 + (1 - progress) * 2 * np.pi,
                        np.pi / 2 + 2 * np.pi, self.radius // 10)
            if self.label is not None:
                self.font = self.font or pg.font.SysFont('Comic Sans MS', 10)
                lbl = self.font.render(str(self.label), False,
                                    anticolor(self.robot.color))
                blit_center(screen, lbl, (x, y))


class TaskDispatcher:
    def __init__(self):
        # task_bins[robot_id] = [ (start, end, task_id, action), ... ]
        self.task_bins = []
        self.start_time = 0.0
    
    def fill_ends(self):
        for bin in self.task_bins:
            for i in range(len(bin) - 1):
                if bin[i][1] is None:
                    bin[i][1] = bin[i+1][0]
            if bin[-1][1] is None:
                bin[-1][1] = math.inf
    
    def fetch_tasks(self, tasks):
        # [ (start, stop, rob_id, action) ]
        num_robots = -1
        for _, _, rob_id, _ in tasks:
            num_robots = max(num_robots, rob_id)
        num_robots += 1
        self.task_bins = [[] for _ in range(num_robots)]
        for task_id, task in enumerate(tasks):
            start, stop, rob_id, action = task
            bin = self.task_bins[rob_id]
            bisect.insort(bin, [start, stop, task_id, action])
        self.fill_ends()
    
    def dispatch(self, t):
        t -= self.start_time
        active_tasks = [None] * len(self.task_bins)
        active_tasks: list[None | Tuple[float, float, int, Any]]
        for agent_id, task_bin in enumerate(self.task_bins):
            active_task_id = bisect.bisect_left(task_bin, [t])
            if active_task_id == 0:
                continue
            active_task_id -= 1
            active_task = task_bin[active_task_id].copy()
            if active_task[1] <= t:
                continue
            active_task[0] += self.start_time
            active_task[1] += self.start_time
            active_tasks[agent_id] = active_task
        self.active_tasks = active_tasks
        return active_tasks


class LocationManager:
    scale = 100      # pixels in a single unit
    box_size = 100   # pixels
    default_color = (60, 60, 60)
    
    def __init__(self, origin=None, scale=None, box_size=None, font=None):
        # point, color, text
        self.org = np.array(origin or (0, 0), float)
        self.loc = []
        self.font = font or pg.font.SysFont(pg.font.get_default_font(),
                                            16)
        if scale is not None:
            self.scale = scale
        if box_size is not None:
            self.box_size = box_size
        elif scale is not None:
            self.box_size = scale

    def pos(self, loc_id) -> Tuple[int, int]:
        pos = self.org + np.multiply(self.scale, self.loc[loc_id][0])
        return tuple(pos.round().astype(int).tolist())

    def index(self, pos):
        pos = tuple(np.array(pos, float).tolist())
        for i, loc in enumerate(self.loc):
            if pos == loc[0]:
                return i
        return self.loc.index(pos)
            
    def render(self, screen: pg.surface.Surface):
        box_size = np.zeros(2)
        box_size[:] = self.box_size
        org = self.org - box_size / 2
        w, h = box_size.astype(int)
        for point, color, text in self.loc:
            if color is None:
                color = self.default_color
            point = org + np.multiply(point, self.scale)
            x, y = point.astype(int)
            pg.draw.rect(screen, color, (x, y, w, h), 1)
            if text is not None:
                lbl = self.font.render(text, False, (0,0,0))
                blit_center(screen, lbl, point + box_size / 2)
        return

    pass


def create_mars(schedule, grid_size=100
                ) -> Tuple[LocationManager, list[Robot], TaskDispatcher]:
    """Creates scene from plan description"""
    # returns tasks, locations, dispatcher and targets
    # plan description does not contain robot home locations
    # if homes is unspecified assume range (0, 0) ... (N, 0)

    locations = LocationManager((grid_size * 2,) * 2,
                                scale=grid_size)
    locs = set()
    for task in schedule['tasks']:
        locs.add(tuple(task['pos']))
    for i, loc in enumerate(locs):
        locations.loc.append([loc, loc_color, f'Loc {i+1}'])
    num_tasks = len(locs)
    for i, home in enumerate(schedule['homes']):
        locations.loc.insert(num_tasks,
                             [tuple(home), home_color, f"Home {i+1}"])
    robots = []
    for rob_id in range(schedule['robots']):
        pid = PID(pid_p, pid_i, pid_d, pid_clip)
        pos = locations.pos(-1-rob_id)
        robot = Robot(pos, robots, pid
                      , f"{rob_id + 1}")
        robot.target = pos
        robot.color = robot_colors[rob_id % len(robot_colors)]
        robots.append(robot)
    tasks = []
    for task in schedule['tasks']:
        pos = tuple(task['pos'])
        loc = locations.index(pos)
        tasks.append([task['start'], task['end'],
                      task['robot'], loc])
    dispatcher = TaskDispatcher()
    dispatcher.fetch_tasks(tasks)
    # now add homing at the end of the run
    for rob_id, bin in enumerate(dispatcher.task_bins):
        task = list(bin[-1])
        task[0] = task[1]
        task[1] += 3.0
        task[2] = f"H{rob_id+1}"
        task[3] = -rob_id-1
        bin.append(task)
    return locations, robots, dispatcher


def main(schedule, output, res, fps):
    pg.font.init()
    # this may be different
    res = tuple(map(int, res.split('x')))
    fps = float(fps)
    dt = 1 / fps
    schedule = load_schedule(schedule)
    locations, robots, dispatcher = create_mars(schedule)
    targets: list[Target] = []
    for robot in robots:
        targets.append(Target(None, None, None, robot))
    t = 0.0
    dispatcher.start_time = t + 5
    if output is None:
        screen = pg.display.set_mode(res)
    else:
        screen = pg.Surface(res)
        recorder = cv2.VideoWriter(output, cv2.VideoWriter.fourcc(*'mp4v'), fps, screen.get_size(), True)
    final_ts = 0.0
    for bin in dispatcher.task_bins:
        for task in bin:
            final_ts = max(final_ts, task[1])
    final_ts += 5.0 + 5.0
    # this is adaptive locations origin and scale
    # rescale and reposition locations so that
    # its geometric center would be exactly in the middle of a screen
    # then rescale it so that its bounding box would be 50px away from border
    points = []
    for point, color, text in locations.loc:
        points.append(point)
    points = np.array(points, float)
    bbox = np.array([points.min(axis=0), points.max(axis=0)]) + [[-1], [1]]
    center = (bbox[0] + bbox[1]) / 2
    size = bbox[1] - bbox[0]
    # size should be equal to (width, height)
    locations.scale = ((screen.get_size() - np.array(100)) / size).min()
    locations.box_size = locations.scale
    # screen_size / 2 = org + center * scale
    # org = screen_size / 2 - center * scale
    org = np.array(screen.get_size()) / 2 - center * locations.scale
    locations.org = org.round().astype(int)
    # recompute robot starting positions
    for rob_id, robot in enumerate(robots):
        pos = locations.pos(-rob_id-1)
        robot.target = pos
        robot.pos = np.array(pos, float)
    running = True
    with tqdm(total=final_ts) as pbar:
        while running:
            if output is None:
                for event in pg.event.get():
                    if event.type == pg.KEYDOWN and event.key == pg.K_ESCAPE:
                        running = False
                    elif event.type == pg.KEYDOWN and event.key == pg.K_SPACE:
                        dispatcher.start_time = t + 2
            active_tasks = dispatcher.dispatch(t)
            screen.fill((255, 255, 255))
            locations.render(screen)
            for robot in robots:
                robot.render(screen)
            for rob_id, task in enumerate(active_tasks):
                if task is not None:
                    start, end, task_id, loc_id = task
                    if isinstance(task_id, int):
                        task_id = f"T{task_id+1}"
                    pos = locations.pos(loc_id)
                    task = (start, end, task_id, pos)
                # this filters Nones and also controls robots as a side effect
                # this is a bad approach and I would like to change it
                targets[rob_id].set(task).render(screen, t)
            for robot in robots:
                robot.control(t)
                robot.physics(t)
            if output is None:
                pg.display.flip()
                time.sleep(dt)
            else:
                img = surf_to_cv(screen)
                recorder.write(img)
                if t == 0.0:
                    import matplotlib.pyplot as plt
                    plt.imshow(img)
                    plt.show()
                if t >= final_ts:
                    running = False
                    recorder.release()
            t += dt
            if t < final_ts:
                pbar.update(dt)
        
if __name__ == '__main__':
    from argparse import ArgumentParser
    argparser = ArgumentParser(description=__doc__)
    argparser.add_argument('-i', "--schedule",
                           required=False,
                           default='./schedules/schedule.json',
                           help='default = "./schedules/schedule.json".'
                           ' A JSON or YAML file to read schedule from.')
    argparser.add_argument("-o", "--out",
                           required=False,
                           help='default = None.'
                           ' Path to output mp4 video')
    argparser.add_argument('-r', '--res', default='800x600',
                           required=False,
                           help='default = 800x600.'
                           ' Screen resolution')
    argparser.add_argument('-f', '--fps', default='20',
                           required=False,
                           help='default = 20.'
                           ' Screen resolution')
    args = argparser.parse_args()
    
    main(args.schedule, args.out, args.res, args.fps)


